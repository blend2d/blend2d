// [Blend2D]
// 2D Vector Graphics Powered by a JIT Compiler.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

#ifndef BLEND2D_BLAPI_H
#define BLEND2D_BLAPI_H

// This header can only be included by either <blend2d.h> or by Blend2D headers
// during the build. Prevent users including <blend2d/> headers by accident and
// prevent not including "blend2d/blapi-build_p.h" during the build.
#if !defined(BLEND2D_H) && !defined(BLEND2D_BLAPI_BUILD_P_H)
  #pragma message("Include either <blend2d.h> or <blend2d-impl.h> to use Blend2D library")
#endif

// ----------------------------------------------------------------------------
// [Documentation]
// ----------------------------------------------------------------------------

//! \mainpage API Reference
//!
//! Blend2D C/C++ API reference documentation generated by Doxygen.
//!
//! \section main_introduction Introduction
//!
//! Blend2D API consists of enumerations, functions, structs, and C++ classes.
//! Common concepts like enumerations and POD structs are shared between C and
//! C++. Some structs contain extra functionality like `BLSomething::reset()`
//! that is only available to C++ users, however, such functionality is only
//! provided for convenience and doesn't affect how Blend2D can be used from C.
//!
//! Blend2D C++ API is in fact build on top of the C API and all C++ functions
//! are inlines that call C API without any overhead. It would require double
//! effort to document both C and C++ APIs separately so we have decided to only
//! document C++ API and to only list \ref blend2d_api_c_functions "C API" for
//! users that need it. The C API should be straightforward and matches very
//! well the C++ part.
//!
//! \section main_important Important
//!
//! Doxygen sorts struct members in anonymous structs and unions and we haven't
//! figured out how to turn this off. This means that the order of members in
//! "Public Attributes" doesn't have to reflect the original struct packing.
//! So please always double-check struct members in case you plan to use
//! braces-based initialization of simple structs.
//!
//! \section main_groups Groups
//!
//! The documentation is split into the following groups:
//!
//! $$DOCS_GROUP_OVERVIEW$$
//!
//! \section main_other Other Pages
//!
//!   - <a href="../getting-started.html">Getting Started</a> - Covers basic
//!     setup and few sample applications
//!   - <a href="annotated.html">Class List</a> - Provides a list of classes
//!     sorted alphabetically

//! \defgroup blend2d_api_globals Globals
//! \brief Global functions, constants,  and classes used universally across
//! the library.

//! \defgroup blend2d_api_geometry Geometry
//! \brief Geometries, paths, and transformations.
//!
//! Blend2D offers various geometry structures and objects that can be used with
//! either `BLPath` for path building or `BLContext` for rendering.

//! \defgroup blend2d_api_images Images
//! \brief Images and image codecs.

//! \defgroup blend2d_api_styles Styles
//! \brief Colors, gradients, and patterns.

//! \defgroup blend2d_api_text Text
//! \brief Fonts & Text support.

//! \defgroup blend2d_api_rendering Rendering
//! \brief 2D rendering context, helper structures, and constants.

//! \defgroup blend2d_api_runtime Runtime
//! \brief Interaction with Blend2D runtime.

//! \defgroup blend2d_api_filesystem Filesystem
//! \brief Filesystem utilities.

//! \defgroup blend2d_api_impl Impl
//! \brief API required for extending Blend2D functionality.
//!
//! Everything that is part of this group requires `<blend2d-impl.h>` to be
//! included before the use as this API is only for users that extend Blend2D.

//! \defgroup blend2d_api_macros Macros
//! \brief Preprocessor macros and compile-time constants.

//! \defgroup blend2d_api_c_functions C API
//! \brief Global C API functions exported as `extern "C"` (C API).
//!
//! We do not document these functions as they are called from C++ wrappers,
//! which should be documented. If you are using C API for embedding Blend2D
//! in other language or C API directly then it's recommended to browse the
//! C++ API first to get an overview of how things work and then check the
//! relation between exported C functions and C++ API.
//!
//! Each type that requires initialization provides `Init` and `Reset` functions
//! These functions are called by C++ constructors and destructors on C++ side
//! and must be used the same way by C users. Although these functions return
//! `BLResult` it's guaranteed to always be `BL_SUCCESS` and such results are
//! only provided to make the API consistent and to make it possible to call
//! `Reset()` functions as tail calls in case some function needs to reset
//! something and then return.
//!
//! The following example should illustrate how `Init` and `Reset` works:
//!
//! ```
//! BLImageCore img;
//! blImageInit(&img);
//! blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! Some init functions may provide shortcuts for the most used scenarios that
//! merge initialization and resource allocation into a single function.
//!
//! ```
//! BLImageCore img;
//! blImageInitAs(&img, 128, 128, BL_FORMAT_PRGB32);
//! blImageReset(&img);
//! ```
//!
//! It's worth nothing that default initialization in Blend2D costs nothing
//! and no resources are allocated, thus initialization never fails and in
//! theory default initialized objects don't have to be reset as they don't
//! hold any data (however never do that in practice). Resetting always resets
//! the object into its default initialized form, so you can reuse such object
//! afterwards (after reset it's still properly initialized) or consider it
//! destroyed.
//!
//! The following example should explain how init/reset works:
//!
//! \code
//! BLImageCore img;
//!
//! // Now image is default constructed/initialized. if you did just this and
//! // abandon it then no resources will be leaked as default construction is
//! // not allocating any resources nor increasing any reference counters.
//! blImageInit(&img);
//!
//! // Now image will have to dynamically allocate some memory to store pixel
//! // data. If this succeeds the image will have to be reset to destroy the
//! // data it holds.
//! BLResult result = blImageCreate(&img, 128, 128, BL_FORMAT_PRGB32);
//! if (result != BL_SUCCESS) {
//!   // If function fails it should behave like it was never called, so `img`
//!   // would still be default initialized in this case. this means that you
//!   // don't have to reset it explicitly although the C++ API would do it in
//!   // image destructor.
//!   return result;
//! }
//!
//! // Resetting image would destroy its data and make it default constructed.
//! blImageReset(&img);
//!
//! // You can still use the image after it has been reset as the data it holds
//! // is still valid, but the image is of course empty.
//! printf("%d", blImageEquals(&img, &img));
//! \endcode

//! \cond INTERNAL

//! \defgroup blend2d_internal Internal
//!
//! \brief Internal API.

//! \defgroup blend2d_internal_codecs Codecs
//!
//! \brief Codecs implementation.

//! \defgroup blend2d_internal_raster Raster
//!
//! \brief Raster rendering context.

//! \defgroup blend2d_internal_pipegen PipeGen
//!
//! \brief Pipeline generator.

//! \defgroup blend2d_internal_opentype OpenType
//!
//! \brief OpenType implementation.

//! \endcond

// ============================================================================
// [Version]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Version Information
//! \{

//! Makes a version number representing a `MAJOR.MINOR.PATCH` combination.
#define BL_MAKE_VERSION(MAJOR, MINOR, PATCH) (((MAJOR) << 16) | ((MINOR) << 8) | (PATCH))

//! Blend2D library version.
#define BL_VERSION BL_MAKE_VERSION(0, 0, 1)

//! \}

//! \}

// ============================================================================
// [Build Options]
// ============================================================================

// These definitions can be used to enable static library build. Embed is used
// when Blend2D's source code is embedded directly in another project, implies
// static build as well.
//
// #define BL_BUILD_EMBED           // Blend2D is embedded (implies BL_BUILD_STATIC).
// #define BL_BUILD_STATIC          // Blend2D is a statically linked library.

// BL_BUILD_EMBED implies BL_BUILD_STATIC.
#if defined(BL_BUILD_EMBED) && !defined(BL_BUILD_STATIC)
  #define BL_BUILD_STATIC
#endif

// These definitions control the build mode and tracing support. The build mode
// should be auto-detected at compile time, but it's possible to override it in
// case that the auto-detection fails.
//
// Tracing is a feature that is never compiled by default and it's only used to
// debug Blend2D itself.
//
// #define BL_BUILD_DEBUG           // Define to enable debug-mode.
// #define BL_BUILD_RELEASE         // Define to enable release-mode.

// Detect BL_BUILD_DEBUG and BL_BUILD_RELEASE if not defined.
#if !defined(BL_BUILD_DEBUG) && !defined(BL_BUILD_RELEASE)
  #ifndef NDEBUG
    #define BL_BUILD_DEBUG
  #else
    #define BL_BUILD_RELEASE
  #endif
#endif

// ============================================================================
// [Dependencies]
// ============================================================================

#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
  #include <new>
  #include <type_traits>
  #include <utility>
#else
  #include <stdbool.h>
#endif

// ============================================================================
// [Public Macros]
// ============================================================================

//! \addtogroup blend2d_api_macros
//! \{

//! \name Target Information
//! \{

//! \def BL_BUILD_BYTE_ORDER
//!
//! A compile-time constant (macro) that defines byte-order of the target. It
//! can be either `1234` for little-endian targets or `4321` for big-endian
//! targets. Blend2D uses this macro internally, but it's also available to
//! end users as sometimes it could be important for deciding between pixel
//! formats or other important details.
#if (defined(__ARMEB__)) || (defined(__MIPSEB__)) || \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
  #define BL_BUILD_BYTE_ORDER 4321
#else
  #define BL_BUILD_BYTE_ORDER 1234
#endif

//! \}

//! \name Decorators
//! \{

//! \def BL_API
//!
//! A base API decorator that marks functions and variables exported by Blend2D.
//! This decorator is internally only used to make `BL_API_C` decorator, which
//! adds `extern "C"` for C linkage.
#if !defined(BL_BUILD_STATIC) && !defined(BL_BUILD_EMBED)
  #if defined(_WIN32) && (defined(_MSC_VER) || defined(__MINGW32__))
    #if defined(BL_BUILD_EXPORT)
      #define BL_API __declspec(dllexport)
    #else
      #define BL_API __declspec(dllimport)
    #endif
  #elif defined(_WIN32) && defined(__GNUC__)
    #if defined(BL_BUILD_EXPORT)
      #define BL_API __attribute__((dllexport))
    #else
      #define BL_API __attribute__((dllimport))
    #endif
  #elif defined(__GNUC__)
    #define BL_API __attribute__((__visibility__("default")))
  #endif
#endif

#ifndef BL_API
  #define BL_API
#endif

//! \def BL_API_C
//!
//! A decorator that marks functions and variables exported by Blend2D to use
//! C linkage. Public API should only use this decorator and not plain `BL_API`.
#if defined(__cplusplus)
  #define BL_API_C extern "C" BL_API
#else
  #define BL_API_C BL_API
#endif

//! \def BL_CDECL
//!
//! Calling convention used by all exported functions and function callbacks.
//! If you pass callbacks to Blend2D it's strongly advised to use this macro,
//! because some compilers provide a way of overriding a global calling
//! convention (like __vectorcall on Windows platforms), which would break the
//! use of such callbacks.
#if defined(_MSC_VER)
  #define BL_CDECL __cdecl
#elif defined(__GNUC__) && defined(__i386__) && !defined(__x86_64__)
  #define BL_CDECL __attribute__((__cdecl__))
#else
  #define BL_CDECL
#endif

//! \def BL_INLINE
//!
//! Marks functions that should always be inlined.

#if defined(_MSC_VER) && !defined(BL_BUILD_DEBUG)
  #define BL_INLINE __forceinline
#elif defined(__GNUC__) && !defined(BL_BUILD_DEBUG)
  #define BL_INLINE inline __attribute__((__always_inline__))
#else
  #define BL_INLINE inline
#endif

//! \def BL_NORETURN
//!
//! Function attribute used by functions that never return (that terminate the
//! process). This attribute is used only once by `blRuntimeAssertionFailure()`
//! function, which is only used when assertions are enabled. This macro should
//! be considered internal and it's not designed for Blend2D users.
#if defined(_MSC_VER)
  #define BL_NORETURN __declspec(noreturn)
#elif defined(__GNUC__)
  #define BL_NORETURN __attribute__((noreturn))
#else
  #define BL_NORETURN
#endif

//! \def BL_NOEXCEPT
//!
//! Defined to `noexcept` in C++17 mode an nothing in C mode. The reason this
//! macro is provided is because Blend2D C API doesn't use exceptions and is
//! marked as such.
#if defined(__cplusplus) && __cplusplus >= 201703L
  // Function typedefs are `noexcept`, however, it's not available until C++17.
  #define BL_NOEXCEPT noexcept
#else
  #define BL_NOEXCEPT
#endif

//! \def BL_NOEXCEPT_C
//!
//! Defined to `noexcept` in C++11 mode an nothing in C mode. This is used to
//! mark Blend2D C API, which is `noexcept` by design.
#if defined(__cplusplus)
  #define BL_NOEXCEPT_C noexcept
#else
  #define BL_NOEXCEPT_C
#endif

//! \}

//! \name Assumptions
//! \{

//! \def BL_ASSUME(...)
//!
//! Macro that tells the C/C++ compiler that the expression `...` evaluates
//! to true. This macro is only used by few places and should be considered
//! internal as you shouldn't need it when using Blend2D library.
#if defined(_MSC_VER)
  #define BL_ASSUME(...) __assume(__VA_ARGS__)
#elif defined(__clang__)
  #define BL_ASSUME(...) __builtin_assume(__VA_ARGS__)
#elif defined(__GNUC__)
  #define BL_ASSUME(...) do { if (!(__VA_ARGS__)) __builtin_unreachable(); } while (0)
#else
  #define BL_ASSUME(...) (void)0
#endif

//! \def BL_LIKELY(...)
//!
//! A condition is likely.

//! \def BL_UNLIKELY(...)
//!
//! A condition is unlikely.

#if defined(__GNUC__)
  #define BL_LIKELY(...) __builtin_expect(!!(__VA_ARGS__), 1)
  #define BL_UNLIKELY(...) __builtin_expect(!!(__VA_ARGS__), 0)
#else
  #define BL_LIKELY(...) (__VA_ARGS__)
  #define BL_UNLIKELY(...) (__VA_ARGS__)
#endif

//! \}

//! \name Debugging and Error Handling
//! \{

//! \def BL_ASSERT(EXP)
//!
//! Run-time assertion executed in debug builds.
#ifdef BL_BUILD_DEBUG
  #define BL_ASSERT(EXP)                                                      \
    do {                                                                      \
      if (BL_UNLIKELY(!(EXP)))                                                \
        blRuntimeAssertionFailure(__FILE__, __LINE__, #EXP);                  \
    } while (0)
#else
  #define BL_ASSERT(EXP) ((void)0)
#endif

//! Executes the code within the macro and returns if it returned any value other
//! than `BL_SUCCESS`. This macro is heavily used across the library for error
//! handling.
#define BL_PROPAGATE(...)                                                     \
  do {                                                                        \
    BLResult resultToPropagate = (__VA_ARGS__);                               \
    if (BL_UNLIKELY(resultToPropagate))                                       \
      return resultToPropagate;                                               \
  } while (0)

//! \}

//! \name Utilities
//! \{

//! Creates a 32-bit tag (uint32_t) from the given `A`, `B`, `C`, and `D` values.
#define BL_MAKE_TAG(A, B, C, D) \
  ((BLTag)(((BLTag)(A) << 24) | ((BLTag)(B) << 16) | ((BLTag)(C) << 8) | ((BLTag)(D))))

//! \}

//! \cond INTERNAL
//! \name Internals
//! \{

//! \def BL_DEFINE_ENUM(NAME)
//!
//! Defines an enumeration used by Blend2D that is `uint32_t`.

//! \}
//! \endcond

#ifdef __cplusplus
  #define BL_DEFINE_ENUM(NAME) enum NAME : uint32_t
#else
  #define BL_DEFINE_ENUM(NAME) enum NAME
#endif

#ifdef __cplusplus
  // Union prevents C++ compiler from constructing / destructing its members.
  #define BL_TYPED_MEMBER(CORE_TYPE, CPP_TYPE, NAME) union { CPP_TYPE NAME; }

  // However, we have to provide default constructors, destructor, and
  // copy-assignment to pay for such union {}.
  #define BL_HAS_TYPED_MEMBERS(...)                                           \
    BL_INLINE __VA_ARGS__() noexcept {}                                       \
    BL_INLINE __VA_ARGS__(const __VA_ARGS__& other) noexcept {                \
      memcpy(this, &other, sizeof(__VA_ARGS__));                              \
    }                                                                         \
    BL_INLINE ~__VA_ARGS__() noexcept {}                                      \
                                                                              \
    BL_INLINE __VA_ARGS__& operator=(const __VA_ARGS__& other) noexcept {     \
      memcpy(this, &other, sizeof(__VA_ARGS__));                              \
      return *this;                                                           \
    }
#else
  #define BL_TYPED_MEMBER(CORE_TYPE, CPP_TYPE, NAME) CORE_TYPE NAME
  #define BL_HAS_TYPED_MEMBERS(...)
#endif

//! \}

// ============================================================================
// [Forward Declarations]
// ============================================================================

#ifdef __cplusplus
  #define BL_DEFINE_STRUCT(NAME) struct NAME
#else
  #define BL_DEFINE_STRUCT(NAME) typedef struct NAME NAME
#endif

BL_DEFINE_STRUCT(BLRange);
BL_DEFINE_STRUCT(BLRandom);
BL_DEFINE_STRUCT(BLCreateForeignInfo);
BL_DEFINE_STRUCT(BLFileCore);

BL_DEFINE_STRUCT(BLRuntimeBuildInfo);
BL_DEFINE_STRUCT(BLRuntimeMemoryInfo);
BL_DEFINE_STRUCT(BLRuntimeCpuInfo);

BL_DEFINE_STRUCT(BLStringCore);
BL_DEFINE_STRUCT(BLStringImpl);
BL_DEFINE_STRUCT(BLArrayCore);
BL_DEFINE_STRUCT(BLArrayImpl);
BL_DEFINE_STRUCT(BLVariantCore);
BL_DEFINE_STRUCT(BLVariantImpl);

BL_DEFINE_STRUCT(BLPointI);
BL_DEFINE_STRUCT(BLPoint);
BL_DEFINE_STRUCT(BLSizeI);
BL_DEFINE_STRUCT(BLSize);
BL_DEFINE_STRUCT(BLBoxI);
BL_DEFINE_STRUCT(BLBox);
BL_DEFINE_STRUCT(BLRectI);
BL_DEFINE_STRUCT(BLRect);
BL_DEFINE_STRUCT(BLLine);
BL_DEFINE_STRUCT(BLTriangle);
BL_DEFINE_STRUCT(BLRoundRect);
BL_DEFINE_STRUCT(BLCircle);
BL_DEFINE_STRUCT(BLEllipse);
BL_DEFINE_STRUCT(BLArc);
BL_DEFINE_STRUCT(BLMatrix2D);
BL_DEFINE_STRUCT(BLPathCore);
BL_DEFINE_STRUCT(BLPathImpl);
BL_DEFINE_STRUCT(BLPathView);
BL_DEFINE_STRUCT(BLRegionCore);
BL_DEFINE_STRUCT(BLRegionImpl);
BL_DEFINE_STRUCT(BLApproximationOptions);
BL_DEFINE_STRUCT(BLStrokeOptionsCore);

BL_DEFINE_STRUCT(BLFormatInfo);
BL_DEFINE_STRUCT(BLImageCore);
BL_DEFINE_STRUCT(BLImageImpl);
BL_DEFINE_STRUCT(BLImageData);
BL_DEFINE_STRUCT(BLImageInfo);
BL_DEFINE_STRUCT(BLImageScaleOptions);
BL_DEFINE_STRUCT(BLPixelConverterCore);
BL_DEFINE_STRUCT(BLPixelConverterOptions);

BL_DEFINE_STRUCT(BLImageCodecCore);
BL_DEFINE_STRUCT(BLImageCodecImpl);
BL_DEFINE_STRUCT(BLImageCodecVirt);
BL_DEFINE_STRUCT(BLImageDecoderCore);
BL_DEFINE_STRUCT(BLImageDecoderImpl);
BL_DEFINE_STRUCT(BLImageDecoderVirt);
BL_DEFINE_STRUCT(BLImageEncoderCore);
BL_DEFINE_STRUCT(BLImageEncoderImpl);
BL_DEFINE_STRUCT(BLImageEncoderVirt);

BL_DEFINE_STRUCT(BLRgba32);
BL_DEFINE_STRUCT(BLRgba64);
BL_DEFINE_STRUCT(BLRgba128);
BL_DEFINE_STRUCT(BLGradientCore);
BL_DEFINE_STRUCT(BLGradientImpl);
BL_DEFINE_STRUCT(BLGradientStop);
BL_DEFINE_STRUCT(BLLinearGradientValues);
BL_DEFINE_STRUCT(BLRadialGradientValues);
BL_DEFINE_STRUCT(BLConicalGradientValues);
BL_DEFINE_STRUCT(BLPatternCore);
BL_DEFINE_STRUCT(BLPatternImpl);

BL_DEFINE_STRUCT(BLContextCore);
BL_DEFINE_STRUCT(BLContextImpl);
BL_DEFINE_STRUCT(BLContextVirt);
BL_DEFINE_STRUCT(BLContextCookie);
BL_DEFINE_STRUCT(BLContextCreateOptions);
BL_DEFINE_STRUCT(BLContextHints);
BL_DEFINE_STRUCT(BLContextState);

BL_DEFINE_STRUCT(BLGlyphBufferCore);
BL_DEFINE_STRUCT(BLGlyphBufferData);
BL_DEFINE_STRUCT(BLGlyphInfo);
BL_DEFINE_STRUCT(BLGlyphItem);
BL_DEFINE_STRUCT(BLGlyphMappingState);
BL_DEFINE_STRUCT(BLGlyphOutlineSinkInfo);
BL_DEFINE_STRUCT(BLGlyphPlacement);
BL_DEFINE_STRUCT(BLGlyphRun);

BL_DEFINE_STRUCT(BLFontTable);
BL_DEFINE_STRUCT(BLFontFeature);
BL_DEFINE_STRUCT(BLFontVariation);
BL_DEFINE_STRUCT(BLFontCoverage);
BL_DEFINE_STRUCT(BLFontPanose);
BL_DEFINE_STRUCT(BLFontMatrix);
BL_DEFINE_STRUCT(BLFontMetrics);
BL_DEFINE_STRUCT(BLFontDesignMetrics);
BL_DEFINE_STRUCT(BLTextMetrics);

BL_DEFINE_STRUCT(BLFontCore);
BL_DEFINE_STRUCT(BLFontImpl);
BL_DEFINE_STRUCT(BLFontVirt);
BL_DEFINE_STRUCT(BLFontFaceCore);
BL_DEFINE_STRUCT(BLFontFaceImpl);
BL_DEFINE_STRUCT(BLFontFaceVirt);
BL_DEFINE_STRUCT(BLFontDataCore);
BL_DEFINE_STRUCT(BLFontDataImpl);
BL_DEFINE_STRUCT(BLFontDataVirt);
BL_DEFINE_STRUCT(BLFontLoaderCore);
BL_DEFINE_STRUCT(BLFontLoaderImpl);
BL_DEFINE_STRUCT(BLFontLoaderVirt);

#undef BL_DEFINE_STRUCT

// C++ API.
#ifdef __cplusplus
class BLFile;
class BLVariant;
template<typename T> class BLArray;
class BLString;
class BLPath;
class BLRegion;
class BLStrokeOptions;
class BLImage;
class BLImageCodec;
class BLImageDecoder;
class BLImageEncoder;
class BLPattern;
class BLGradient;
class BLContext;
class BLPixelConverter;
class BLGlyphBuffer;
class BLGlyphRunIterator;
class BLFont;
class BLFontData;
class BLFontFace;
class BLFontLoader;
#endif

// ============================================================================
// [Public Types]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Result code used by most Blend2D functions (32-bit unsigned integer).
//!
//! The `BLResultCode` enumeration contains Blend2D result codes that contain
//! Blend2D specific set of errors and an extended set of errors that can come
//! from WIN32 or POSIX APIs. Since the success result code is zero it's
//! recommended to use the following check to determine whether a call failed
//! or not:
//!
//! ```
//! BLResult result = doSomething();
//! if (result != BL_SUCCESS) {
//!   // `doSomething()` failed...
//! }
//! ```
typedef uint32_t BLResult;

//! \ingroup blend2d_api_globals
//!
//! A type used to store a pack of bits (typedef to `uintptr_t`).
//!
//! BitWord should be equal in size to a machine word.
typedef uintptr_t BLBitWord;

//! \ingroup blend2d_api_globals
//!
//! Tag is a 32-bit integer consisting of 4 characters in the following format:
//!
//! ```
//! tag = ((a << 24) | (b << 16) | (c << 8) | d)
//! ```
//!
//! Tags are used extensively by OpenType fonts and other binary formats like
//! PNG. In most cases TAGs should only contain ASCII letters, digits, and spaces.
//!
//! Blend2D uses `BLTag` in public and internal APIs to distinguish between a
//! regular `uint32_t` and tag.
typedef uint32_t BLTag;

//! \ingroup blend2d_api_globals
//!
//! A function callback that is called when an Impl is destroyed. It's often used
//! to notify that a data passed to a certain Impl is no longer in use.
typedef void (BL_CDECL* BLDestroyImplFunc)(void* impl, void* destroyData) BL_NOEXCEPT;

//! \ingroup blend2d_api_geometry
//!
//! Optional callback that can be used to consume a path data.
typedef BLResult (BL_CDECL* BLPathSinkFunc)(BLPathCore* path, const void* info, void* closure) BL_NOEXCEPT;

//! \ingroup blend2d_api_text
//!
//! Glyph identifier is an index to a glyph stored in a font.
//!
//! GlyphId is always an unsigned 16-bit integer as used by TrueType and OpenType
//! fonts. There are some libraries that use 32-bit integers for Glyph indexes,
//! but values above 65535 are never used in practice as font's generally do
//! not have the ability to index more than 65535 glyphs (excluding null glyph).
typedef uint16_t BLGlyphId;

// ============================================================================
// [Constants]
// ============================================================================

//! \ingroup blend2d_api_globals
//!
//! Blend2D result code.
BL_DEFINE_ENUM(BLResultCode) {
  //! Successful result code.
  BL_SUCCESS = 0,

  BL_ERROR_START_INDEX = 0x00010000u,

  BL_ERROR_OUT_OF_MEMORY = 0x00010000u,  //!< Out of memory                 [ENOMEM].
  BL_ERROR_INVALID_VALUE,                //!< Invalid value/argument        [EINVAL].
  BL_ERROR_INVALID_STATE,                //!< Invalid state                 [EFAULT].
  BL_ERROR_INVALID_HANDLE,               //!< Invalid handle or file.       [EBADF].
  BL_ERROR_VALUE_TOO_LARGE,              //!< Value too large               [EOVERFLOW].
  BL_ERROR_NOT_INITIALIZED,              //!< Not initialize (some instance is built-in none when it shouldn't be).
  BL_ERROR_NOT_IMPLEMENTED,              //!< Not implemented               [ENOSYS].
  BL_ERROR_NOT_PERMITTED,                //!< Operation not permitted       [EPERM].

  BL_ERROR_IO,                           //!< IO error                      [EIO].
  BL_ERROR_BUSY,                         //!< Device or resource busy       [EBUSY].
  BL_ERROR_INTERRUPTED,                  //!< Operation interrupted         [EINTR].
  BL_ERROR_TRY_AGAIN,                    //!< Try again                     [EAGAIN].
  BL_ERROR_BROKEN_PIPE,                  //!< Broken pipe                   [EPIPE].
  BL_ERROR_INVALID_SEEK,                 //!< File is not seekable          [ESPIPE].
  BL_ERROR_SYMLINK_LOOP,                 //!< Too many levels of symlinks   [ELOOP].
  BL_ERROR_FILE_TOO_LARGE,               //!< File is too large             [EFBIG].
  BL_ERROR_ALREADY_EXISTS,               //!< File/directory already exists [EEXIST].
  BL_ERROR_ACCESS_DENIED,                //!< Access denied                 [EACCES].
  BL_ERROR_MEDIA_CHANGED,                //!< Media changed                 [Windows::ERROR_MEDIA_CHANGED].
  BL_ERROR_READ_ONLY_FS,                 //!< The file/FS is read-only      [EROFS].
  BL_ERROR_NO_DEVICE,                    //!< Device doesn't exist          [ENXIO].
  BL_ERROR_NO_ENTRY,                     //!< No such file or directory     [ENOENT].
  BL_ERROR_NO_MEDIA,                     //!< No media in drive/device      [ENOMEDIUM].
  BL_ERROR_NO_MORE_DATA,                 //!< No more data / end of file    [ENODATA].
  BL_ERROR_NO_MORE_FILES,                //!< No more files                 [ENMFILE].
  BL_ERROR_NO_SPACE_LEFT,                //!< No space left on device       [ENOSPC].
  BL_ERROR_NOT_EMPTY,                    //!< Directory is not empty        [ENOTEMPTY].
  BL_ERROR_NOT_FILE,                     //!< Not a file                    [EISDIR].
  BL_ERROR_NOT_DIRECTORY,                //!< Not a directory               [ENOTDIR].
  BL_ERROR_NOT_SAME_DEVICE,              //!< Not same device               [EXDEV].
  BL_ERROR_NOT_BLOCK_DEVICE,             //!< Not a block device            [ENOTBLK].

  BL_ERROR_INVALID_FILE_NAME,            //!< File/path name is invalid     [n/a].
  BL_ERROR_FILE_NAME_TOO_LONG,           //!< File/path name is too long    [ENAMETOOLONG].

  BL_ERROR_TOO_MANY_OPEN_FILES,          //!< Too many open files           [EMFILE].
  BL_ERROR_TOO_MANY_OPEN_FILES_BY_OS,    //!< Too many open files by OS     [ENFILE].
  BL_ERROR_TOO_MANY_LINKS,               //!< Too many symbolic links on FS [EMLINK].

  BL_ERROR_FILE_EMPTY,                   //!< File is empty (not specific to any OS error).
  BL_ERROR_OPEN_FAILED,                  //!< File open failed              [Windows::ERROR_OPEN_FAILED].
  BL_ERROR_NOT_ROOT_DEVICE,              //!< Not a root device/directory   [Windows::ERROR_DIR_NOT_ROOT].

  BL_ERROR_UNKNOWN_SYSTEM_ERROR,         //!< Unknown system error that failed to translate to Blend2D result code.

  BL_ERROR_INVALID_SIGNATURE,            //!< Invalid data signature or header.
  BL_ERROR_INVALID_DATA,                 //!< Invalid or corrupted data.
  BL_ERROR_INVALID_STRING,               //!< Invalid string (invalid data of either UTF8, UTF16, or UTF32).
  BL_ERROR_DATA_TRUNCATED,               //!< Truncated data (more data required than memory/stream provides).
  BL_ERROR_DATA_TOO_LARGE,               //!< Input data too large to be processed.
  BL_ERROR_DECOMPRESSION_FAILED,         //!< Decompression failed due to invalid data (RLE, Huffman, etc).

  BL_ERROR_INVALID_GEOMETRY,             //!< Invalid geometry (invalid path data or shape).
  BL_ERROR_NO_MATCHING_VERTEX,           //!< Returned when there is no matching vertex in path data.

  BL_ERROR_NO_MATCHING_COOKIE,           //!< No matching cookie (BLContext).
  BL_ERROR_NO_STATES_TO_RESTORE,         //!< No states to restore (BLContext).

  BL_ERROR_IMAGE_TOO_LARGE,              //!< The size of the image is too large.
  BL_ERROR_IMAGE_NO_MATCHING_CODEC,      //!< Image codec for a required format doesn't exist.
  BL_ERROR_IMAGE_UNKNOWN_FILE_FORMAT,    //!< Unknown or invalid file format that cannot be read.
  BL_ERROR_IMAGE_DECODER_NOT_PROVIDED,   //!< Image codec doesn't support reading the file format.
  BL_ERROR_IMAGE_ENCODER_NOT_PROVIDED,   //!< Image codec doesn't support writing the file format.

  BL_ERROR_PNG_MULTIPLE_IHDR,            //!< Multiple IHDR chunks are not allowed (PNG).
  BL_ERROR_PNG_INVALID_IDAT,             //!< Invalid IDAT chunk (PNG).
  BL_ERROR_PNG_INVALID_IEND,             //!< Invalid IEND chunk (PNG).
  BL_ERROR_PNG_INVALID_PLTE,             //!< Invalid PLTE chunk (PNG).
  BL_ERROR_PNG_INVALID_TRNS,             //!< Invalid tRNS chunk (PNG).
  BL_ERROR_PNG_INVALID_FILTER,           //!< Invalid filter type (PNG).

  BL_ERROR_JPEG_UNSUPPORTED_FEATURE,     //!< Unsupported feature (JPEG).
  BL_ERROR_JPEG_INVALID_SOS,             //!< Invalid SOS marker or header (JPEG).
  BL_ERROR_JPEG_INVALID_SOF,             //!< Invalid SOF marker (JPEG).
  BL_ERROR_JPEG_MULTIPLE_SOF,            //!< Multiple SOF markers (JPEG).
  BL_ERROR_JPEG_UNSUPPORTED_SOF,         //!< Unsupported SOF marker (JPEG).

  BL_ERROR_FONT_NO_CHARACTER_MAPPING,    //!< Font has no character to glyph mapping data.
  BL_ERROR_FONT_MISSING_IMPORTANT_TABLE, //!< Font has missing an important table.
  BL_ERROR_FONT_FEATURE_NOT_AVAILABLE,   //!< Font feature is not available.
  BL_ERROR_FONT_CFF_INVALID_DATA,        //!< Font has an invalid CFF data.
  BL_ERROR_FONT_PROGRAM_TERMINATED,      //!< Font program terminated because the execution reached the limit.

  BL_ERROR_INVALID_GLYPH                 //!< Invalid glyph identifier.
};

//! \ingroup blend2d_api_globals
//!
//! Byte order.
BL_DEFINE_ENUM(BLByteOrder) {
  //! Little endian byte-order.
  BL_BYTE_ORDER_LE = 0,
  //! Big endian byte-order.
  BL_BYTE_ORDER_BE = 1,

  //! Native (host) byte-order.
  BL_BYTE_ORDER_NATIVE = BL_BUILD_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_LE : BL_BYTE_ORDER_BE,
  //! Swapped byte-order (BE if host is LE and vice versa).
  BL_BYTE_ORDER_SWAPPED = BL_BUILD_BYTE_ORDER == 1234 ? BL_BYTE_ORDER_BE : BL_BYTE_ORDER_LE
};

//! \ingroup blend2d_api_globals
//!
//! Data access type.
BL_DEFINE_ENUM(BLDataAccessType) {
  //! Invalid or no data.
  BL_DATA_ACCESS_TYPE_NONE = 0,
  //! Read-only access.
  BL_DATA_ACCESS_TYPE_RO = 1,
  //! Read/write access.
  BL_DATA_ACCESS_TYPE_RW = 2,

  //! Count of data access types.
  BL_DATA_ACCESS_TYPE_COUNT = 3
};

//! \ingroup blend2d_api_globals
//!
//! Data source type.
BL_DEFINE_ENUM(BLDataSourceType) {
  //! No data source.
  BL_DATA_SOURCE_TYPE_NONE = 0,
  //! Memory data source.
  BL_DATA_SOURCE_TYPE_MEMORY = 1,
  //! File data source.
  BL_DATA_SOURCE_TYPE_FILE = 2,
  //! Custom data source.
  BL_DATA_SOURCE_TYPE_CUSTOM = 3,

  //! Count of data source types.
  BL_DATA_SOURCE_TYPE_COUNT = 4
};

//! \ingroup blend2d_api_globals
//!
//! Modification operation applied to Blend2D containers.
BL_DEFINE_ENUM(BLModifyOp) {
  //! Assign operation and reserve only space to fit the input.
  BL_MODIFY_OP_ASSIGN_FIT = 0,
  //! Assign operation and reserve more capacity for growing.
  BL_MODIFY_OP_ASSIGN_GROW = 1,
  //! Append operation and reserve only space to fit the input.
  BL_MODIFY_OP_APPEND_FIT = 2,
  //! Append operation and reserve more capacity for growing.
  BL_MODIFY_OP_APPEND_GROW = 3,

  //! Count of data operations.
  BL_MODIFY_OP_COUNT = 4
};

//! \ingroup blend2d_api_globals
//!
//! Boolean operator.
BL_DEFINE_ENUM(BLBooleanOp) {
  //! Result = B.
  BL_BOOLEAN_OP_COPY = 0,
  //! Result = A & B.
  BL_BOOLEAN_OP_AND = 1,
  //! Result = A | B.
  BL_BOOLEAN_OP_OR = 2,
  //! Result = A ^ B.
  BL_BOOLEAN_OP_XOR = 3,
  //! Result = A - B.
  BL_BOOLEAN_OP_SUB = 4,

  BL_BOOLEAN_OP_COUNT = 5
};

//! \ingroup blend2d_api_styles
//!
//! Extend mode.
BL_DEFINE_ENUM(BLExtendMode) {
  //! Pad extend [default].
  BL_EXTEND_MODE_PAD = 0,
  //! Repeat extend.
  BL_EXTEND_MODE_REPEAT = 1,
  //! Reflect extend.
  BL_EXTEND_MODE_REFLECT = 2,

  //! Alias to `BL_EXTEND_MODE_PAD`.
  BL_EXTEND_MODE_PAD_X_PAD_Y = 0,
  //! Alias to `BL_EXTEND_MODE_REPEAT`.
  BL_EXTEND_MODE_REPEAT_X_REPEAT_Y = 1,
  //! Alias to `BL_EXTEND_MODE_REFLECT`.
  BL_EXTEND_MODE_REFLECT_X_REFLECT_Y = 2,
  //! Pad X and repeat Y.
  BL_EXTEND_MODE_PAD_X_REPEAT_Y = 3,
  //! Pad X and reflect Y.
  BL_EXTEND_MODE_PAD_X_REFLECT_Y = 4,
  //! Repeat X and pad Y.
  BL_EXTEND_MODE_REPEAT_X_PAD_Y = 5,
  //! Repeat X and reflect Y.
  BL_EXTEND_MODE_REPEAT_X_REFLECT_Y = 6,
  //! Reflect X and pad Y.
  BL_EXTEND_MODE_REFLECT_X_PAD_Y = 7,
  //! Reflect X and repeat Y.
  BL_EXTEND_MODE_REFLECT_X_REPEAT_Y = 8,

  //! Count of simple extend modes (that use the same value for X and Y).
  BL_EXTEND_MODE_SIMPLE_COUNT = 3,
  //! Count of complex extend modes (that can use independent values for X and Y).
  BL_EXTEND_MODE_COMPLEX_COUNT = 9
};

//! \ingroup blend2d_api_styles
//!
//! Style type.
BL_DEFINE_ENUM(BLStyleType) {
  //! No style, nothing will be paint.
  BL_STYLE_TYPE_NONE = 0,
  //! Solid color style.
  BL_STYLE_TYPE_SOLID = 1,
  //! Pattern style.
  BL_STYLE_TYPE_PATTERN = 2,
  //! Gradient style.
  BL_STYLE_TYPE_GRADIENT = 3,

  //! Count of style types.
  BL_STYLE_TYPE_COUNT = 4
};

//! \ingroup blend2d_api_text
//!
//! Text encoding.
BL_DEFINE_ENUM(BLTextEncoding) {
  //! UTF-8 encoding.
  BL_TEXT_ENCODING_UTF8 = 0,
  //! UTF-16 encoding (native endian).
  BL_TEXT_ENCODING_UTF16 = 1,
  //! UTF-32 encoding (native endian).
  BL_TEXT_ENCODING_UTF32 = 2,
  //! LATIN1 encoding (one byte per character).
  BL_TEXT_ENCODING_LATIN1 = 3,

  //! Platform native `wchar_t` (or Windows `WCHAR`) encoding, alias to
  //! either UTF-32, UTF-16, or UTF-8 depending on `sizeof(wchar_t)`.
  BL_TEXT_ENCODING_WCHAR
    = sizeof(wchar_t) == 4 ? BL_TEXT_ENCODING_UTF32 :
      sizeof(wchar_t) == 2 ? BL_TEXT_ENCODING_UTF16 : BL_TEXT_ENCODING_UTF8,

  //! Count of text supported text encodings.
  BL_TEXT_ENCODING_COUNT = 4
};

// ============================================================================
// [Public API (Inline)]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! \name Debugging Functionality
//! \{

//! Returns the `result` passed.
//!
//! Provided for debugging purposes. Putting a breakpoint inside `blTraceError()`
//! can help with tracing an origin of errors reported / returned by Blend2D as
//! each error goes through this function.
//!
//! It's a zero-cost solution that doesn't affect release builds in any way.
static inline BLResult blTraceError(BLResult result) BL_NOEXCEPT_C { return result; }

//! \}

//! \}

// These are the only global functions provided in C++ mode. They are needed by
// C++ API wrappers and can be used freely by Blend2D users as these templates
// have specializations for some geometry types. For example `blMin(a, b)` works
// with numbers as well as with `BLPoint`.

#ifdef __cplusplus
//! \cond INTERNAL

//! \ingroup blend2d_internal
//!
//! Internal namespace that should never be used by Blend2D users.
namespace BLInternal {

//! StdInt provides an integer defined by <stdint.h> by size and signedness.
//!
//! This struct is visible to Blend2D users, because it's required by the
//! `BLArray<>` template. However, it's still considered internal and should
//! not be used outside of Blend2D source code.
template<size_t Size, unsigned Unsigned>
struct StdInt {};

template<> struct StdInt<1, 0> { typedef int8_t   Type; };
template<> struct StdInt<1, 1> { typedef uint8_t  Type; };
template<> struct StdInt<2, 0> { typedef int16_t  Type; };
template<> struct StdInt<2, 1> { typedef uint16_t Type; };
template<> struct StdInt<4, 0> { typedef int32_t  Type; };
template<> struct StdInt<4, 1> { typedef uint32_t Type; };
template<> struct StdInt<8, 0> { typedef int64_t  Type; };
template<> struct StdInt<8, 1> { typedef uint64_t Type; };

//! Implementation of `blDownCast()`, which can be used to downcast a Blend2D
//! core struct / object into its C++ counterpart. The cast is always safe.
template<typename T>
struct DownCast { T Type; };

#define BL_DCAST_IMPL(T) template<> struct DownCast<T##Core> { typedef T Type; }

BL_DCAST_IMPL(BLContext);
BL_DCAST_IMPL(BLFile);
BL_DCAST_IMPL(BLFont);
BL_DCAST_IMPL(BLFontData);
BL_DCAST_IMPL(BLFontFace);
BL_DCAST_IMPL(BLFontLoader);
BL_DCAST_IMPL(BLGlyphBuffer);
BL_DCAST_IMPL(BLGradient);
BL_DCAST_IMPL(BLImage);
BL_DCAST_IMPL(BLImageCodec);
BL_DCAST_IMPL(BLImageDecoder);
BL_DCAST_IMPL(BLImageEncoder);
BL_DCAST_IMPL(BLPath);
BL_DCAST_IMPL(BLPattern);
BL_DCAST_IMPL(BLPixelConverter);
BL_DCAST_IMPL(BLRegion);
BL_DCAST_IMPL(BLString);
BL_DCAST_IMPL(BLStrokeOptions);
BL_DCAST_IMPL(BLVariant);

#undef BL_DCAST_IMPL

} // {BLInternal}

//! \endcond

//! \addtogroup blend2d_api_globals
//! \{

//! \name Global C++ Functions
//! \{

//! Returns an absolute value of `a`.
template<typename T>
constexpr T blAbs(const T& a) noexcept { return T(a < 0 ? -a : a); }

//! Returns a minimum value of `a` and `b`.
template<typename T>
constexpr T blMin(const T& a, const T& b) noexcept { return T(b < a ? b : a); }

//! Returns a maximum value of `a` and `b`.
template<typename T>
constexpr T blMax(const T& a, const T& b) noexcept { return T(a < b ? b : a); }

//! Clamps `a` to a range defined as `[b, c]`.
template<typename T>
constexpr T blClamp(const T& a, const T& b, const T& c) noexcept { return blMin(c, blMax(b, a)); }

//! Returns a minimum value of all arguments passed.
template<typename T, typename... Args>
constexpr T blMin(const T& a, const T& b, Args&&... args) noexcept { return blMin(blMin(a, b), std::forward<Args>(args)...); }

//! Returns a maximum value of all arguments passed.
template<typename T, typename... Args>
constexpr T blMax(const T& a, const T& b, Args&&... args) noexcept { return blMax(blMax(a, b), std::forward<Args>(args)...); }

//! Returns `true` if `a` and `b` equals at binary level.
//!
//! For example `blEquals(NaN, NaN) == true`.
template<typename T>
BL_INLINE bool blEquals(const T& a, const T& b) noexcept { return a == b; }

//! \cond
template<>
BL_INLINE bool blEquals(const float& a, const float& b) noexcept {
  union { float f32[2]; uint32_t u32[2]; } view {{ a, b }};
  return view.u32[0] == view.u32[1];
}

template<>
BL_INLINE bool blEquals(const double& a, const double& b) noexcept {
  union { double f64[2]; uint64_t u64[2]; } view {{ a, b }};
  return view.u64[0] == view.u64[1];
}
//! \endcond

//! \}

//! \name Downcasting from Core type to C++ type.
//! \{

//! Downcasts a core type like `BLContextCore` into a C++ type like `BLContext`.
//! Intended to be used by C++ users that work with C API as well (by either
//! providing it directly or using some other code that uses Blend2D C API).
template<typename T>
static constexpr typename BLInternal::DownCast<T>::Type& blDownCast(T& ref) noexcept {
  return reinterpret_cast<typename BLInternal::DownCast<T>::Type&>(ref);
}

//! \overload
template<typename T>
static constexpr const typename BLInternal::DownCast<T>::Type& blDownCast(const T& ref) noexcept {
  return reinterpret_cast<const typename BLInternal::DownCast<T>::Type&>(ref);
}

//! \overload
template<typename T>
static constexpr typename BLInternal::DownCast<T>::Type* blDownCast(T* ptr) noexcept {
  return reinterpret_cast<typename BLInternal::DownCast<T>::Type*>(ptr);
}

//! \overload
template<typename T>
static constexpr const typename BLInternal::DownCast<T>::Type* blDownCast(const T* ptr) noexcept {
  return reinterpret_cast<const typename BLInternal::DownCast<T>::Type*>(ptr);
}

//! \}
//! \}

#endif

// ============================================================================
// [BLRange]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Provides start and end indexes. It's used to specify a range of an operation
//! related to indexed containers like `BLArray`, `BLPath`, `BLGradient`, etc...
struct BLRange {
  size_t start;
  size_t end;

  // --------------------------------------------------------------------------
  #ifdef __cplusplus

  //! Create an uninitialized range.
  BL_INLINE BLRange() noexcept = default;
  //! Create a copy of `other` range.
  constexpr BLRange(const BLRange&) noexcept = default;

  //! Create a range from `start` to `end`.
  constexpr explicit BLRange(size_t start, size_t end) noexcept
    : start(start),
      end(end) {}

  static constexpr BLRange everything() noexcept { return BLRange(0, SIZE_MAX); }

  //! Reset the range to [0, 0).
  BL_INLINE void reset() noexcept { reset(0, 0); }
  //! Reset the range to [start, end).
  BL_INLINE void reset(size_t start, size_t end) noexcept {
    this->start = start;
    this->end = end;
  }

  BL_INLINE bool equals(const BLRange& other) const noexcept {
    return blEquals(this->start, other.start) &
           blEquals(this->end  , other.end  ) ;
  }

  BL_INLINE bool operator==(const BLRange& other) const noexcept { return  equals(other); }
  BL_INLINE bool operator!=(const BLRange& other) const noexcept { return !equals(other); }

  #endif
  // --------------------------------------------------------------------------
};

//! \}

// ============================================================================
// [BLCreateForeignInfo]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

//! Structure passed to a constructor (initializer) that provides foreign data
//! that should be used to allocate its Impl (and data if it's a container).
struct BLCreateForeignInfo {
  void* data;
  size_t size;
  BLDestroyImplFunc destroyFunc;
  void* destroyData;
};

//! \}

// ============================================================================
// [BLArrayView]
// ============================================================================

//! \addtogroup blend2d_api_globals
//! \{

#ifdef __cplusplus

//! Array view of `T`.
//!
//! NOTE: In C mode the type of data used by `BLArrayView` is `const void*`,
//! thus it has to be retyped to a real type this view points to. There are
//! only few specializations like `BLStringView` that point to a real type.
template<typename T>
struct BLArrayView {
  const T* data;
  size_t size;

  BL_INLINE void reset() noexcept {
    this->data = nullptr;
    this->size = 0;
  }

  BL_INLINE void reset(const T* data, size_t size) noexcept {
    this->data = data;
    this->size = size;
  }

  BL_INLINE const T* begin() const noexcept { return this->data; }
  BL_INLINE const T* end() const noexcept { return this->data + this->size; }
};

// In C++ mode these are just typedefs of `BLArrayView<Type>`.

//! View of char[] data used by String.
typedef BLArrayView<char> BLStringView;

//! View of BLBoxI[] data used by Region.
typedef BLArrayView<BLBoxI> BLRegionView;

//! View of untyped data.
typedef BLArrayView<void> BLDataView;

#else

#define BL_DEFINE_ARRAY_VIEW(NAME, TYPE) \
  typedef struct {                       \
    const TYPE* data;                    \
    size_t size;                         \
  } NAME

BL_DEFINE_ARRAY_VIEW(BLArrayView, void);
BL_DEFINE_ARRAY_VIEW(BLStringView, char);
BL_DEFINE_ARRAY_VIEW(BLRegionView, BLBoxI);

typedef BLArrayView BLDataView;

#undef BL_DEFINE_ARRAY_VIEW

#endif

//! \}

// ============================================================================
// [C Interface - Core]
// ============================================================================

//! \addtogroup blend2d_api_c_functions
//! \{

//! \name BLArray
//!
//! C API uses must call either generic functions with `Item` suffix or correct
//! specialized functions in case of typed arrays. For example if you create a
//! `BLArray<uint32_t>` in C then you can only modify it through functions that
//! have either `U32` or `Item` suffix. Arrays of signed types are treated as
//! arrays of unsigned types at API level as there is no difference between them
//! from implementation perspective.
//!
//! \{
BL_API_C BLResult BL_CDECL blArrayInit(BLArrayCore* self, uint32_t arrayTypeId) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReset(BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blArrayGetSize(const BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blArrayGetCapacity(const BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C const void* BL_CDECL blArrayGetData(const BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayClear(BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayShrink(BLArrayCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReserve(BLArrayCore* self, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayResize(BLArrayCore* self, size_t n, const void* fill) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayMakeMutable(BLArrayCore* self, void** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayModifyOp(BLArrayCore* self, uint32_t op, size_t n, void** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertOp(BLArrayCore* self, size_t index, size_t n, void** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAssignMove(BLArrayCore* self, BLArrayCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAssignWeak(BLArrayCore* self, const BLArrayCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAssignDeep(BLArrayCore* self, const BLArrayCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAssignView(BLArrayCore* self, const void* items, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendU8(BLArrayCore* self, uint8_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendU16(BLArrayCore* self, uint16_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendU32(BLArrayCore* self, uint32_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendU64(BLArrayCore* self, uint64_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendF32(BLArrayCore* self, float value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendF64(BLArrayCore* self, double value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendItem(BLArrayCore* self, const void* item) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayAppendView(BLArrayCore* self, const void* items, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertU8(BLArrayCore* self, size_t index, uint8_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertU16(BLArrayCore* self, size_t index, uint16_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertU32(BLArrayCore* self, size_t index, uint32_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertU64(BLArrayCore* self, size_t index, uint64_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertF32(BLArrayCore* self, size_t index, float value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertF64(BLArrayCore* self, size_t index, double value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertItem(BLArrayCore* self, size_t index, const void* item) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayInsertView(BLArrayCore* self, size_t index, const void* items, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceU8(BLArrayCore* self, size_t index, uint8_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceU16(BLArrayCore* self, size_t index, uint16_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceU32(BLArrayCore* self, size_t index, uint32_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceU64(BLArrayCore* self, size_t index, uint64_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceF32(BLArrayCore* self, size_t index, float value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceF64(BLArrayCore* self, size_t index, double value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceItem(BLArrayCore* self, size_t index, const void* item) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayReplaceView(BLArrayCore* self, const BLRange* range, const void* items, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayRemoveIndex(BLArrayCore* self, size_t index) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blArrayRemoveRange(BLArrayCore* self, const BLRange* range) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blArrayEquals(const BLArrayCore* a, const BLArrayCore* b) BL_NOEXCEPT_C;
//! \}

//! \name BLContext
//! \{
BL_API_C BLResult BL_CDECL blContextInit(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextInitAs(BLContextCore* self, BLImageCore* image, const BLContextCreateOptions* options) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextReset(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextAssignMove(BLContextCore* self, BLContextCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextAssignWeak(BLContextCore* self, const BLContextCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextBegin(BLContextCore* self, BLImageCore* image, const BLContextCreateOptions* options) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextEnd(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFlush(BLContextCore* self, uint32_t flags) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSave(BLContextCore* self, BLContextCookie* cookie) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextRestore(BLContextCore* self, const BLContextCookie* cookie) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextUserToMeta(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextMatrixOp(BLContextCore* self, uint32_t opType, const void* opData) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetHint(BLContextCore* self, uint32_t hintType, uint32_t value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetHints(BLContextCore* self, const BLContextHints* hints) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFlattenMode(BLContextCore* self, uint32_t mode) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFlattenTolerance(BLContextCore* self, double tolerance) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetApproximationOptions(BLContextCore* self, const BLApproximationOptions* options) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetCompOp(BLContextCore* self, uint32_t compOp) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetGlobalAlpha(BLContextCore* self, double alpha) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFillRule(BLContextCore* self, uint32_t fillRule) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFillAlpha(BLContextCore* self, double alpha) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetFillStyle(const BLContextCore* self, void* object) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetFillStyleRgba32(const BLContextCore* self, uint32_t* rgba32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetFillStyleRgba64(const BLContextCore* self, uint64_t* rgba64) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFillStyle(BLContextCore* self, const void* object) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFillStyleRgba32(BLContextCore* self, uint32_t rgba32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetFillStyleRgba64(BLContextCore* self, uint64_t rgba64) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeWidth(BLContextCore* self, double width) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeMiterLimit(BLContextCore* self, double miterLimit) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeCap(BLContextCore* self, uint32_t position, uint32_t strokeCap) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeCaps(BLContextCore* self, uint32_t strokeCap) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeJoin(BLContextCore* self, uint32_t strokeJoin) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeDashOffset(BLContextCore* self, double dashOffset) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeDashArray(BLContextCore* self, const BLArrayCore* dashArray) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeTransformOrder(BLContextCore* self, uint32_t transformOrder) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeOptions(BLContextCore* self, const BLStrokeOptionsCore* options) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeAlpha(BLContextCore* self, double alpha) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetStrokeStyle(const BLContextCore* self, void* object) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetStrokeStyleRgba32(const BLContextCore* self, uint32_t* rgba32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextGetStrokeStyleRgba64(const BLContextCore* self, uint64_t* rgba64) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeStyle(BLContextCore* self, const void* object) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeStyleRgba32(BLContextCore* self, uint32_t rgba32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextSetStrokeStyleRgba64(BLContextCore* self, uint64_t rgba64) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextClipToRectI(BLContextCore* self, const BLRectI* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextClipToRectD(BLContextCore* self, const BLRect* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextRestoreClipping(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextClearAll(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextClearRectI(BLContextCore* self, const BLRectI* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextClearRectD(BLContextCore* self, const BLRect* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillAll(BLContextCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillRectI(BLContextCore* self, const BLRectI* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillRectD(BLContextCore* self, const BLRect* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillPathD(BLContextCore* self, const BLPathCore* path) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillGeometry(BLContextCore* self, uint32_t geometryType, const void* geometryData) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillTextI(BLContextCore* self, const BLPointI* pt, const BLFontCore* font, const void* text, size_t size, uint32_t encoding) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillTextD(BLContextCore* self, const BLPoint* pt, const BLFontCore* font, const void* text, size_t size, uint32_t encoding) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillGlyphRunI(BLContextCore* self, const BLPointI* pt, const BLFontCore* font, const BLGlyphRun* glyphRun) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextFillGlyphRunD(BLContextCore* self, const BLPoint* pt, const BLFontCore* font, const BLGlyphRun* glyphRun) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeRectI(BLContextCore* self, const BLRectI* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeRectD(BLContextCore* self, const BLRect* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokePathD(BLContextCore* self, const BLPathCore* path) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeGeometry(BLContextCore* self, uint32_t geometryType, const void* geometryData) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeTextI(BLContextCore* self, const BLPointI* pt, const BLFontCore* font, const void* text, size_t size, uint32_t encoding) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeTextD(BLContextCore* self, const BLPoint* pt, const BLFontCore* font, const void* text, size_t size, uint32_t encoding) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeGlyphRunI(BLContextCore* self, const BLPointI* pt, const BLFontCore* font, const BLGlyphRun* glyphRun) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextStrokeGlyphRunD(BLContextCore* self, const BLPoint* pt, const BLFontCore* font, const BLGlyphRun* glyphRun) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextBlitImageI(BLContextCore* self, const BLPointI* pt, const BLImageCore* img, const BLRectI* imgArea) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextBlitImageD(BLContextCore* self, const BLPoint* pt, const BLImageCore* img, const BLRectI* imgArea) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextBlitScaledImageI(BLContextCore* self, const BLRectI* rect, const BLImageCore* img, const BLRectI* imgArea) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blContextBlitScaledImageD(BLContextCore* self, const BLRect* rect, const BLImageCore* img, const BLRectI* imgArea) BL_NOEXCEPT_C;
//! \}

//! \name BLFile
//! \{
BL_API_C BLResult BL_CDECL blFileInit(BLFileCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileReset(BLFileCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileOpen(BLFileCore* self, const char* fileName, uint32_t openFlags) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileClose(BLFileCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileSeek(BLFileCore* self, int64_t offset, uint32_t seekType, int64_t* positionOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileRead(BLFileCore* self, void* buffer, size_t n, size_t* bytesReadOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileWrite(BLFileCore* self, const void* buffer, size_t n, size_t* bytesWrittenOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileTruncate(BLFileCore* self, int64_t maxSize) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileGetSize(BLFileCore* self, uint64_t* fileSizeOut) BL_NOEXCEPT_C;
//! \}

//! \name BLFileSystem
//! \{
BL_API_C BLResult BL_CDECL blFileSystemReadFile(const char* fileName, BLArrayCore* dst, size_t maxSize) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFileSystemWriteFile(const char* fileName, const void* data, size_t size, size_t* bytesWrittenOut) BL_NOEXCEPT_C;
//! \}

//! \name BLFont
//! \{
BL_API_C BLResult BL_CDECL blFontInit(BLFontCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontReset(BLFontCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontAssignMove(BLFontCore* self, BLFontCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontAssignWeak(BLFontCore* self, const BLFontCore* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blFontEquals(const BLFontCore* a, const BLFontCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontCreateFromFace(BLFontCore* self, const BLFontFaceCore* face, float size) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontShape(const BLFontCore* self, BLGlyphBufferCore* buf) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontMapTextToGlyphs(const BLFontCore* self, BLGlyphBufferCore* buf, BLGlyphMappingState* stateOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontPositionGlyphs(const BLFontCore* self, BLGlyphBufferCore* buf, uint32_t positioningFlags) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontApplyKerning(const BLFontCore* self, BLGlyphBufferCore* buf) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontApplyGSub(const BLFontCore* self, BLGlyphBufferCore* buf, size_t index, BLBitWord lookups) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontApplyGPos(const BLFontCore* self, BLGlyphBufferCore* buf, size_t index, BLBitWord lookups) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontGetTextMetrics(const BLFontCore* self, BLGlyphBufferCore* buf, BLTextMetrics* out) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontGetGlyphBounds(const BLFontCore* self, const void* glyphIdData, intptr_t glyphIdAdvance, BLBoxI* out, size_t count) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontGetGlyphAdvances(const BLFontCore* self, const void* glyphIdData, intptr_t glyphIdAdvance, BLGlyphPlacement* out, size_t count) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontGetGlyphOutlines(const BLFontCore* self, uint32_t glyphId, const BLMatrix2D* userMatrix, BLPathCore* out, BLPathSinkFunc sink, void* closure) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontGetGlyphRunOutlines(const BLFontCore* self, const BLGlyphRun* glyphRun, const BLMatrix2D* userMatrix, BLPathCore* out, BLPathSinkFunc sink, void* closure) BL_NOEXCEPT_C;
//! \}

//! \name BLFontData
//! \{
BL_API_C BLResult BL_CDECL blFontDataInit(BLFontDataCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontDataReset(BLFontDataCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontDataAssignMove(BLFontDataCore* self, BLFontDataCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontDataAssignWeak(BLFontDataCore* self, const BLFontDataCore* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blFontDataEquals(const BLFontDataCore* a, const BLFontDataCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontDataListTags(const BLFontDataCore* self, BLArrayCore* dst) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blFontDataQueryTables(const BLFontDataCore* self, BLFontTable* dst, const BLTag* tags, size_t count) BL_NOEXCEPT_C;
//! \}

//! \name BLFontFace
//! \{
BL_API_C BLResult BL_CDECL blFontFaceInit(BLFontFaceCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontFaceReset(BLFontFaceCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontFaceAssignMove(BLFontFaceCore* self, BLFontFaceCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontFaceAssignWeak(BLFontFaceCore* self, const BLFontFaceCore* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blFontFaceEquals(const BLFontFaceCore* a, const BLFontFaceCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontFaceCreateFromFile(BLFontFaceCore* self, const char* fileName) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontFaceCreateFromLoader(BLFontFaceCore* self, const BLFontLoaderCore* loader, uint32_t faceIndex) BL_NOEXCEPT_C;
//! \}

//! \name BLFontLoader
//! \{
BL_API_C BLResult BL_CDECL blFontLoaderInit(BLFontLoaderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderReset(BLFontLoaderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderAssignMove(BLFontLoaderCore* self, BLFontLoaderCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderAssignWeak(BLFontLoaderCore* self, const BLFontLoaderCore* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blFontLoaderEquals(const BLFontLoaderCore* a, const BLFontLoaderCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderCreateFromFile(BLFontLoaderCore* self, const char* fileName) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderCreateFromDataArray(BLFontLoaderCore* self, const BLArrayCore* dataArray) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blFontLoaderCreateFromData(BLFontLoaderCore* self, const void* data, size_t size, BLDestroyImplFunc destroyFunc, void* destroyData) BL_NOEXCEPT_C;
BL_API_C BLFontDataImpl* BL_CDECL blFontLoaderDataByFaceIndex(BLFontLoaderCore* self, uint32_t faceIndex) BL_NOEXCEPT_C;
//! \}

//! \name BLFormat
//! \{
BL_API_C BLResult BL_CDECL blFormatInfoSanitize(BLFormatInfo* self) BL_NOEXCEPT_C;
//! \}

//! \name BLGlyphBuffer
//! \{
BL_API_C BLResult BL_CDECL blGlyphBufferInit(BLGlyphBufferCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGlyphBufferReset(BLGlyphBufferCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGlyphBufferClear(BLGlyphBufferCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGlyphBufferSetText(BLGlyphBufferCore* self, const void* data, size_t size, uint32_t encoding) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGlyphBufferSetGlyphIds(BLGlyphBufferCore* self, const void* data, intptr_t advance, size_t size) BL_NOEXCEPT_C;
//! \}

//! \name BLGradient
//! \{
BL_API_C BLResult BL_CDECL blGradientInit(BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientInitAs(BLGradientCore* self, uint32_t type, const void* values, uint32_t extendMode, const BLGradientStop* stops, size_t n, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientReset(BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientAssignMove(BLGradientCore* self, BLGradientCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientAssignWeak(BLGradientCore* self, const BLGradientCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientCreate(BLGradientCore* self, uint32_t type, const void* values, uint32_t extendMode, const BLGradientStop* stops, size_t n, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientShrink(BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientReserve(BLGradientCore* self, size_t n) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blGradientGetType(const BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientSetType(BLGradientCore* self, uint32_t type) BL_NOEXCEPT_C;
BL_API_C double   BL_CDECL blGradientGetValue(const BLGradientCore* self, size_t index) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientSetValue(BLGradientCore* self, size_t index, double value) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientSetValues(BLGradientCore* self, size_t index, const double* values, size_t n) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blGradientGetExtendMode(BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientSetExtendMode(BLGradientCore* self, uint32_t extendMode) BL_NOEXCEPT_C;
BL_API_C const BLGradientStop* BL_CDECL blGradientGetStops(const BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C size_t BL_CDECL blGradientGetSize(const BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C size_t BL_CDECL blGradientGetCapacity(const BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientResetStops(BLGradientCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientAssignStops(BLGradientCore* self, const BLGradientStop* stops, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientAddStopRgba32(BLGradientCore* self, double offset, uint32_t argb32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientAddStopRgba64(BLGradientCore* self, double offset, uint64_t argb64) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientRemoveStop(BLGradientCore* self, size_t index) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientRemoveStopByOffset(BLGradientCore* self, double offset, uint32_t all) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientRemoveStops(BLGradientCore* self, const BLRange* range) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientRemoveStopsFromTo(BLGradientCore* self, double offsetMin, double offsetMax) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientReplaceStopRgba32(BLGradientCore* self, size_t index, double offset, uint32_t rgba32) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientReplaceStopRgba64(BLGradientCore* self, size_t index, double offset, uint64_t rgba64) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blGradientIndexOfStop(const BLGradientCore* self, double offset) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blGradientApplyMatrixOp(BLGradientCore* self, uint32_t opType, const void* opData) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blGradientEquals(const BLGradientCore* a, const BLGradientCore* b) BL_NOEXCEPT_C;
//! \}

//! \name BLImage
//! \{
BL_API_C BLResult BL_CDECL blImageInit(BLImageCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageInitAs(BLImageCore* self, int w, int h, uint32_t format) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageReset(BLImageCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageAssignMove(BLImageCore* self, BLImageCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageAssignWeak(BLImageCore* self, const BLImageCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageAssignDeep(BLImageCore* self, const BLImageCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCreate(BLImageCore* self, int w, int h, uint32_t format) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCreateFromData(BLImageCore* self, int w, int h, uint32_t format, void* pixelData, intptr_t stride, BLDestroyImplFunc destroyFunc, void* destroyData) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageGetData(const BLImageCore* self, BLImageData* dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageMakeMutable(BLImageCore* self, BLImageData* dataOut) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blImageEquals(const BLImageCore* a, const BLImageCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageScale(BLImageCore* dst, const BLImageCore* src, const BLSizeI* size, uint32_t filter, const BLImageScaleOptions* options) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageReadFromFile(BLImageCore* self, const char* fileName, const BLArrayCore* codecs) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageReadFromData(BLImageCore* self, const void* data, size_t size, const BLArrayCore* codecs) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageWriteToFile(const BLImageCore* self, const char* fileName, const BLImageCodecCore* codec) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageWriteToData(const BLImageCore* self, BLArrayCore* dst, const BLImageCodecCore* codec) BL_NOEXCEPT_C;
//! \}

//! \name BLImageCodec
//! \{
BL_API_C BLResult BL_CDECL blImageCodecInit(BLImageCodecCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecReset(BLImageCodecCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecAssignWeak(BLImageCodecCore* self, const BLImageCodecCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecFindByName(BLImageCodecCore* self, const BLArrayCore* codecs, const char* name) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecFindByData(BLImageCodecCore* self, const BLArrayCore* codecs, const void* data, size_t size) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blImageCodecInspectData(const BLImageCodecCore* self, const void* data, size_t size) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecCreateDecoder(const BLImageCodecCore* self, BLImageDecoderCore* dst) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageCodecCreateEncoder(const BLImageCodecCore* self, BLImageEncoderCore* dst) BL_NOEXCEPT_C;
BL_API_C BLArrayCore* BL_CDECL blImageCodecBuiltInCodecs(void) BL_NOEXCEPT_C;
//! \}

//! \name BLImageDecoder
//! \{
BL_API_C BLResult BL_CDECL blImageDecoderInit(BLImageDecoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderReset(BLImageDecoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderAssignMove(BLImageDecoderCore* self, BLImageDecoderCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderAssignWeak(BLImageDecoderCore* self, const BLImageDecoderCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderRestart(BLImageDecoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderReadInfo(BLImageDecoderCore* self, BLImageInfo* infoOut, const uint8_t* data, size_t size) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageDecoderReadFrame(BLImageDecoderCore* self, BLImageCore* imageOut, const uint8_t* data, size_t size) BL_NOEXCEPT_C;
//! \}

//! \name BLImageEncoder
//! \{
BL_API_C BLResult BL_CDECL blImageEncoderInit(BLImageEncoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageEncoderReset(BLImageEncoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageEncoderAssignMove(BLImageEncoderCore* self, BLImageEncoderCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageEncoderAssignWeak(BLImageEncoderCore* self, const BLImageEncoderCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageEncoderRestart(BLImageEncoderCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blImageEncoderWriteFrame(BLImageEncoderCore* self, BLArrayCore* dst, const BLImageCore* image) BL_NOEXCEPT_C;
//! \}

//! \name BLMatrix2D
//! \{
BL_API_C BLResult BL_CDECL blMatrix2DSetIdentity(BLMatrix2D* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DSetTranslation(BLMatrix2D* self, double x, double y) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DSetScaling(BLMatrix2D* self, double x, double y) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DSetSkewing(BLMatrix2D* self, double x, double y) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DSetRotation(BLMatrix2D* self, double angle, double cx, double cy) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DApplyOp(BLMatrix2D* self, uint32_t opType, const void* opData) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DInvert(BLMatrix2D* dst, const BLMatrix2D* src) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blMatrix2DGetType(const BLMatrix2D* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blMatrix2DMapPointDArray(const BLMatrix2D* self, BLPoint* dst, const BLPoint* src, size_t count) BL_NOEXCEPT_C;
//! \}

//! \name BLPath
//! \{
BL_API_C BLResult BL_CDECL blPathInit(BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathReset(BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blPathGetSize(const BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blPathGetCapacity(const BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C const uint8_t* BL_CDECL blPathGetCommandData(const BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C const BLPoint* BL_CDECL blPathGetVertexdData(const BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathClear(BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathShrink(BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathReserve(BLPathCore* self, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathModifyOp(BLPathCore* self, uint32_t op, size_t n, uint8_t** cmdDataOut, BLPoint** vtxDataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAssignMove(BLPathCore* self, BLPathCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAssignWeak(BLPathCore* self, const BLPathCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAssignDeep(BLPathCore* self, const BLPathCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathSetVertexAt(BLPathCore* self, size_t index, uint32_t cmd, double x, double y) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathMoveTo(BLPathCore* self, double x0, double y0) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathLineTo(BLPathCore* self, double x1, double y1) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathPolyTo(BLPathCore* self, const BLPoint* poly, size_t count) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathQuadTo(BLPathCore* self, double x1, double y1, double x2, double y2) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathCubicTo(BLPathCore* self, double x1, double y1, double x2, double y2, double x3, double y3) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathSmoothQuadTo(BLPathCore* self, double x2, double y2) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathSmoothCubicTo(BLPathCore* self, double x2, double y2, double x3, double y3) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathArcTo(BLPathCore* self, double x, double y, double rx, double ry, double start, double sweep, bool forceMoveTo) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathArcQuadrantTo(BLPathCore* self, double x1, double y1, double x2, double y2) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathEllipticArcTo(BLPathCore* self, double rx, double ry, double xAxisRotation, bool largeArcFlag, bool sweepFlag, double x1, double y1) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathClose(BLPathCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddGeometry(BLPathCore* self, uint32_t geometryType, const void* geometryData, const BLMatrix2D* m, uint32_t dir) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddBoxI(BLPathCore* self, const BLBoxI* box, uint32_t dir) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddBoxD(BLPathCore* self, const BLBox* box, uint32_t dir) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddRectI(BLPathCore* self, const BLRectI* rect, uint32_t dir) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddRectD(BLPathCore* self, const BLRect* rect, uint32_t dir) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddPath(BLPathCore* self, const BLPathCore* other, const BLRange* range) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddTranslatedPath(BLPathCore* self, const BLPathCore* other, const BLRange* range, const BLPoint* p) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddTransformedPath(BLPathCore* self, const BLPathCore* other, const BLRange* range, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddReversedPath(BLPathCore* self, const BLPathCore* other, const BLRange* range, uint32_t reverseMode) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathAddStrokedPath(BLPathCore* self, const BLPathCore* other, const BLRange* range, const BLStrokeOptionsCore* options, const BLApproximationOptions* approx) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathTranslate(BLPathCore* self, const BLRange* range, const BLPoint* p) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathTransform(BLPathCore* self, const BLRange* range, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathFitTo(BLPathCore* self, const BLRange* range, const BLRect* rect, uint32_t fitFlags) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blPathEquals(const BLPathCore* a, const BLPathCore* b) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetInfoFlags(const BLPathCore* self, uint32_t* flagsOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetControlBox(const BLPathCore* self, BLBox* boxOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetBoundingBox(const BLPathCore* self, BLBox* boxOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetFigureRange(const BLPathCore* self, size_t index, BLRange* rangeOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetLastVertex(const BLPathCore* self, BLPoint* vtxOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPathGetClosestVertex(const BLPathCore* self, const BLPoint* p, double maxDistance, size_t* indexOut, double* distanceOut) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blPathHitTest(const BLPathCore* self, const BLPoint* p, uint32_t fillRule) BL_NOEXCEPT_C;
//! \}

//! \name BLPattern
//! \{
BL_API_C BLResult BL_CDECL blPatternInit(BLPatternCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternInitAs(BLPatternCore* self, const BLImageCore* image, const BLRectI* area, uint32_t extendMode, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternReset(BLPatternCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternAssignMove(BLPatternCore* self, BLPatternCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternAssignWeak(BLPatternCore* self, const BLPatternCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternAssignDeep(BLPatternCore* self, const BLPatternCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternCreate(BLPatternCore* self, const BLImageCore* image, const BLRectI* area, uint32_t extendMode, const BLMatrix2D* m) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternSetImage(BLPatternCore* self, const BLImageCore* image, const BLRectI* area) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternSetArea(BLPatternCore* self, const BLRectI* area) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternSetExtendMode(BLPatternCore* self, uint32_t extendMode) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPatternApplyMatrixOp(BLPatternCore* self, uint32_t opType, const void* opData) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blPatternEquals(const BLPatternCore* a, const BLPatternCore* b) BL_NOEXCEPT_C;
//! \}

//! \name BLPixelConverter
//! \{
BL_API_C BLResult BL_CDECL blPixelConverterInit(BLPixelConverterCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPixelConverterInitWeak(BLPixelConverterCore* self, const BLPixelConverterCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPixelConverterReset(BLPixelConverterCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPixelConverterAssign(BLPixelConverterCore* self, const BLPixelConverterCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blPixelConverterCreate(BLPixelConverterCore* self, const BLFormatInfo* dstInfo, const BLFormatInfo* srcInfo) BL_NOEXCEPT_C;

BL_API_C BLResult BL_CDECL blPixelConverterConvert(const BLPixelConverterCore* self,
  void* dstData, intptr_t dstStride,
  const void* srcData, intptr_t srcStride,
  uint32_t w, uint32_t h, const BLPixelConverterOptions* options) BL_NOEXCEPT_C;
//! \}

//! \name BLRandom
//! \{
BL_API_C void     BL_CDECL blRandomReset(BLRandom* self, uint64_t seed) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blRandomNextUInt32(BLRandom* self) BL_NOEXCEPT_C;
BL_API_C uint64_t BL_CDECL blRandomNextUInt64(BLRandom* self) BL_NOEXCEPT_C;
BL_API_C double   BL_CDECL blRandomNextDouble(BLRandom* self) BL_NOEXCEPT_C;
//! \}

//! \name BLRegion
//! \{
BL_API_C BLResult BL_CDECL blRegionInit(BLRegionCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionReset(BLRegionCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionClear(BLRegionCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionShrink(BLRegionCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionReserve(BLRegionCore* self, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignMove(BLRegionCore* self, BLRegionCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignWeak(BLRegionCore* self, const BLRegionCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignDeep(BLRegionCore* self, const BLRegionCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignBoxI(BLRegionCore* self, const BLBoxI* src) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignBoxIArray(BLRegionCore* self, const BLBoxI* data, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignRectI(BLRegionCore* self, const BLRectI* rect) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionAssignRectIArray(BLRegionCore* self, const BLRectI* data, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionCombine(BLRegionCore* self, const BLRegionCore* a, const BLRegionCore* b, uint32_t op) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionCombineRB(BLRegionCore* self, const BLRegionCore* a, const BLBoxI* b, uint32_t op) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionCombineBR(BLRegionCore* self, const BLBoxI* a, const BLRegionCore* b, uint32_t op) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionCombineBB(BLRegionCore* self, const BLBoxI* a, const BLBoxI* b, uint32_t op) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionTranslate(BLRegionCore* self, const BLRegionCore* r, const BLPointI* pt) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionTranslateAndClip(BLRegionCore* self, const BLRegionCore* r, const BLPointI* pt, const BLBoxI* clipBox) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRegionIntersectAndClip(BLRegionCore* self, const BLRegionCore* a, const BLRegionCore* b, const BLBoxI* clipBox) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blRegionEquals(const BLRegionCore* a, const BLRegionCore* b) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blRegionGetType(const BLRegionCore* self) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blRegionHitTest(const BLRegionCore* self, const BLPointI* pt) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blRegionHitTestBoxI(const BLRegionCore* self, const BLBoxI* box) BL_NOEXCEPT_C;
//! \}

//! \name BLRuntime
//! \{
BL_API_C BLResult BL_CDECL blRuntimeInit() BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeShutdown() BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeCleanup(uint32_t cleanupFlags) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeQueryInfo(uint32_t infoType, void* infoOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeMessageOut(const char* msg) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeMessageFmt(const char* fmt, ...) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blRuntimeMessageVFmt(const char* fmt, va_list ap) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blRuntimeGetTickCount(void) BL_NOEXCEPT_C;

BL_API_C BL_NORETURN void BL_CDECL blRuntimeAssertionFailure(const char* file, int line, const char* msg) BL_NOEXCEPT_C;

#ifdef _WIN32
BL_API_C BLResult BL_CDECL blResultFromWinError(uint32_t e) BL_NOEXCEPT_C;
#else
BL_API_C BLResult BL_CDECL blResultFromPosixError(int e) BL_NOEXCEPT_C;
#endif
//! \}

//! \name BLString
//! \{
BL_API_C BLResult BL_CDECL blStringInit(BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringReset(BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blStringGetSize(const BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C size_t   BL_CDECL blStringGetCapacity(const BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C const char* BL_CDECL blStringGetData(const BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringClear(BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringShrink(BLStringCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringReserve(BLStringCore* self, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringResize(BLStringCore* self, size_t n, char fill) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringMakeMutable(BLStringCore* self, char** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringModifyOp(BLStringCore* self, uint32_t op, size_t n, char** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringInsertOp(BLStringCore* self, size_t index, size_t n, char** dataOut) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringAssignMove(BLStringCore* self, BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringAssignWeak(BLStringCore* self, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringAssignDeep(BLStringCore* self, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringAssignData(BLStringCore* self, const char* str, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringApplyOpChar(BLStringCore* self, uint32_t op, char c, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringApplyOpData(BLStringCore* self, uint32_t op, const char* str, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringApplyOpString(BLStringCore* self, uint32_t op, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringApplyOpFormat(BLStringCore* self, uint32_t op, const char* fmt, ...) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringApplyOpFormatV(BLStringCore* self, uint32_t op, const char* fmt, va_list ap) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringInsertChar(BLStringCore* self, size_t index, char c, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringInsertData(BLStringCore* self, size_t index, const char* str, size_t n) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringInsertString(BLStringCore* self, size_t index, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStringRemoveRange(BLStringCore* self, const BLRange* range) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blStringEquals(const BLStringCore* self, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blStringEqualsData(const BLStringCore* self, const char* str, size_t n) BL_NOEXCEPT_C;
BL_API_C int      BL_CDECL blStringCompare(const BLStringCore* self, const BLStringCore* other) BL_NOEXCEPT_C;
BL_API_C int      BL_CDECL blStringCompareData(const BLStringCore* self, const char* str, size_t n) BL_NOEXCEPT_C;
//! \}

//! \name BLStrokeOptions
//! \{
BL_API_C BLResult BL_CDECL blStrokeOptionsInit(BLStrokeOptionsCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStrokeOptionsInitMove(BLStrokeOptionsCore* self, BLStrokeOptionsCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStrokeOptionsInitWeak(BLStrokeOptionsCore* self, const BLStrokeOptionsCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStrokeOptionsReset(BLStrokeOptionsCore* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStrokeOptionsAssignMove(BLStrokeOptionsCore* self, BLStrokeOptionsCore* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blStrokeOptionsAssignWeak(BLStrokeOptionsCore* self, const BLStrokeOptionsCore* other) BL_NOEXCEPT_C;
//! \}

//! \name BLVariant
//! \{
BL_API_C BLResult BL_CDECL blVariantInit(void* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blVariantInitMove(void* self, void* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blVariantInitWeak(void* self, const void* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blVariantReset(void* self) BL_NOEXCEPT_C;
BL_API_C uint32_t BL_CDECL blVariantGetImplType(const void* self) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blVariantAssignMove(void* self, void* other) BL_NOEXCEPT_C;
BL_API_C BLResult BL_CDECL blVariantAssignWeak(void* self, const void* other) BL_NOEXCEPT_C;
BL_API_C bool     BL_CDECL blVariantEquals(const void* a, const void* b) BL_NOEXCEPT_C;
//! \}

//! \}

#endif // BLEND2D_BLAPI_H
